---
title: Advent of Code 2025
date: 2025-12-01 00:00:01
programming/languages:
- Rust
programming/sources:
- Advent of Code
series:
- Advent of Code 2025
---
It's back! ([[Advent of Code]]())!

It's been ten years (of advent of code, I haven't done them all (yet)) and oh what a ten years it's been. This time around, there will be only 12 days instead of 25, but honestly, that means I'm not working on these right up until Christmas. So I'm okay with this. 

Once again, Rust! But this time, I won't be using `cargo-aoc`, instead I wrote my own proc macros. Mostly to see if I could. :smile: See [this section](#my-very-own-aoc-macros) for more information. 

Full solutions will once again be posted to GitHub (including previous years and possibly some I haven't written up yet): <a href="https://github.com/jpverkamp/advent-of-code">jpverkamp/advent-of-code</a>

<!--more-->

Here are (or will be) all of my solutions:

{{< taxonomy-list "series" "Advent of Code 2025" >}}

Here's how long each solution takes to run:

| Day | Part | Solution                | Benchmark                  |
| --- | ---- | ----------------------- | -------------------------- |
| 1   | 1    | `part1`                 | 215.243µs ± 11.937µs       |
| 1   | 2    | `part2`                 | 2.237187ms ± 52.313µs      |
| 1   | 2    | `part2_inline`          | 1.870518ms ± 50.308µs      |
| 2   | 1    | `part1`                 | 46.189482ms ± 467.675µs    |
| 2   | 1    | `part1_regex`           | 838.820205ms ± 10.505208ms |
| 2   | 1    | `part1_intmatch`        | 11.533401ms ± 1.266642ms   |
| 2   | 1    | `part1_intmatch_divrem` | 9.121032ms ± 85.661µs      |
| 2   | 1    | `part1_chatgpt`         | 650.796µs ± 231.766µs      |
| 2   | 2    | `part2`                 | 110.797727ms ± 5.697853ms  |
| 2   | 2    | `part2_intmatch`        | 100.421589ms ± 1.573153ms  |
| 3   | 1    | `part1`                 | 1.31203ms ± 23.678µs       |
| 3   | 1    | `part1_max_digits`      | 54.131µs ± 2.798µs         |
| 3   | 2    | `part2`                 | 147.712µs ± 5.738µs        |
| 4   | 1    | `part1`                 | 107.041µs ± 5.007µs        |
| 4   | 2    | `part2`                 | 4.826662ms ± 86.921µs      |
| 4   | 2    | `part2_no_map`          | 1.164075ms ± 33.765µs      |
| 4   | 2    | `part2_floodfill`       | 670.268µs ± 19.006µs       |
| 5   | 1    | `part1`                 | 69.969µs ± 2.217µs         |
| 5   | 2    | `part2`                 | 261.825µs ± 12.143µs       |
| 5   | 2    | `part2_bruteforce`      | ~43 weeks :smile:          |
| 6   | 1    | `part1`                 | 38.877µs ± 3.178µs         |
| 6   | 1    | `part1_grid`            | 39.811µs ± 3.344µs         |
| 6   | 2    | `part2`                 | 34.372µs ± 1.887µs         |
| 7   | 1    | `part1`                 | 50.033µs ± 3.791µs         |
| 7   | 2    | `part2`                 | 45.279µs ± 3.015µs         |
| 8   | 1    | `part1`                 | 16.634383ms ± 418.086µs    |
| 8   | 1    | `part1_heap`            | 8.19521ms ± 314.775µs      |
| 8   | 2    | `part2`                 | 16.977939ms ± 497.608µs    |
| 9   | 1    | `part1`                 | 113.22µs ± 5.711µs         |
| 9   | 2    | `part2`                 | 117.772829ms ± 5.835355ms  |
| 9   | 2    | `part2_area_first`      | 75.460115ms ± 4.87159ms    |
| 10  | 1    | `part1`                 | 1.212226433s ± 13.832532ms |
| 10  | 1    | `part1_rayon`           | 331.882295ms ± 5.14392ms   |
| 10  | 2    | `part2_z3_rayon`        | 129.899304ms ± 2.541906ms  |
| 10  | 2    | `part2_eqn_rayon`       | 79.115645459s ± 0ns        |
| 11  | 1    | `part1`                 | 127.686µs ± 3.013µs        |
| 11  | 2    | `part2_memo`            | 4.545146ms ± 78.356µs      |
| 12  | 1    | `part1`                 | 96.430551417s ± 0ns        |
| 12  | 1    | `part1_trivial`         | 153.807µs ± 8.791µs        |

And here are my previous year's solutions:

- [Advent of Code 2015]({{<ref "2015-12-01-advent-of-code-week-1.md">}})
- [Advent of Code 2016]({{<ref "2016-12-01-advent-of-code-year-2.md">}})
- [Advent of Code 2017]({{<ref "2017-12-01-advent-of-code-year-3.md">}})
- [Advent of Code 2018]({{<ref "2018-12-01-advent-of-code-year-4.md">}})
- [Advent of Code 2021]({{<ref "2021-12-01-advent-of-code-2021.md">}})
- [Advent of Code 2022]({{<ref "2022-12-01-advent-of-code-2022.md">}})
- [Advent of Code 2023]({{<ref "2023-12-01-advent-of-code-2023.md">}})
- [Advent of Code 2024]({{<ref "2024-12-01-advent-of-code-2024.md">}})


# My very own AOC macros

I like `cargo aoc` well enough, but I wanted to see what I could write for myself. And also, I can tune this one as I go (if that comes up). So we have a macro in three parts:

## Registering solutions

First, the macro you use to tag functions as solutions:

```rust
pub fn register_impl(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let func = parse_macro_input!(item as ItemFn);
    let fn_name = func.sig.ident.clone();
    let name_str = fn_name.to_string();

    let entry_ident: Ident = quote::format_ident!("__AOC_ENTRY_{}", fn_name.to_string().to_uppercase());
    let shim_ident: Ident = quote::format_ident!("__aoc_shim_{}", fn_name);
    let reg_ident: Ident = quote::format_ident!("__aoc_register_{}", fn_name);

    let name_lit = name_str;

    let expanded = quote! {
        #func

        #[doc(hidden)]
        fn #shim_ident(input: &str) -> String { #fn_name(input).into() }

        #[doc(hidden)]
        static #entry_ident: crate::__aoc::Entry = crate::__aoc::Entry { day: crate::__aoc::DAY, name: #name_lit, func: #shim_ident };

        #[doc(hidden)]
        #[::ctor::ctor]
        fn #reg_ident() { crate::__aoc::register(&#entry_ident); }
    };

    TokenStream::from(expanded)
}
```

This uses the 'registry' from `aoc_main!` below, to do basically all the work. But all you have to do is register it:

```rust
#[aoc::register]
fn part1(input: &str) -> impl Into<String> {
    ...
}
```

And voila!

It will automatically pick up the name of the function as the name used to run it in the CLI (coming up...)

## Write a main function (with CLI params)

This is the real meat of the functionality. It takes the registered functions above and builds out a CLI for each day, supporting:

```bash
$ ./target/release/day1 --help

Usage: day1 <COMMAND>

Commands:
  list
  run
  bench
  help   Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help

$ ./target/release/day1 run --help

Usage: day1 run [OPTIONS] [NAME] [INPUT]

Arguments:
  [NAME]   Name of the solution to run (if not using --all)
  [INPUT]  Input path (use '-' for stdin)

Options:
      --all   Run all registered solutions for the day
  -h, --help  Print help
```

So you can `list` possible solutions, `run` one (or `--all` of them), or `bench`mark them. Pretty nice for basically free (after the first writing of course). 

It is a bit inefficient in that this code will be generated for each day's binary, but :shrug:. Space is cheap. 

Here it is!

```rust
pub fn main_impl(input: TokenStream) -> TokenStream {
    let day_expr = parse_macro_input!(input as Expr);
    let day_str = crate::expr_to_string(&day_expr);

    let expanded = quote! {
        #[doc(hidden)]
        mod __aoc {
            use std::sync::{Mutex, OnceLock};
            pub const DAY: &str = #day_str;
            pub struct Entry { pub day: &'static str, pub name: &'static str, pub func: fn(&str) -> String }
            pub struct RenderEntry { pub day: &'static str, pub name: &'static str, pub func: fn(&str) }

            static REGISTRY: OnceLock<Mutex<Vec<&'static Entry>>> = OnceLock::new();
            static RENDER_REGISTRY: OnceLock<Mutex<Vec<&'static RenderEntry>>> = OnceLock::new();

            pub fn register(e: &'static Entry) { let reg = REGISTRY.get_or_init(|| Mutex::new(Vec::new())); reg.lock().unwrap().push(e); }
            pub fn register_render(e: &'static RenderEntry) { let reg = RENDER_REGISTRY.get_or_init(|| Mutex::new(Vec::new())); reg.lock().unwrap().push(e); }

            pub fn entries_for_day(day: &str) -> Vec<&'static Entry> {
                let reg = REGISTRY.get_or_init(|| Mutex::new(Vec::new()));
                let mut v: Vec<&'static Entry> = reg.lock().unwrap().iter().copied().filter(|e| e.day == day).collect();
                v.sort_by(|a,b| a.name.cmp(b.name)); v
            }

            pub fn render_entries_for_day(day: &str) -> Vec<&'static RenderEntry> {
                let reg = RENDER_REGISTRY.get_or_init(|| Mutex::new(Vec::new()));
                let mut v: Vec<&'static RenderEntry> = reg.lock().unwrap().iter().copied().filter(|e| e.day == day).collect();
                v.sort_by(|a,b| a.name.cmp(b.name)); v
            }

            pub fn get(day: &str, name: &str) -> Option<&'static Entry> {
                let reg = REGISTRY.get_or_init(|| Mutex::new(Vec::new()));
                reg.lock().unwrap().iter().copied().find(|e| e.day == day && e.name == name)
            }

            pub fn get_render(day: &str, name: &str) -> Option<&'static RenderEntry> {
                let reg = RENDER_REGISTRY.get_or_init(|| Mutex::new(Vec::new()));
                reg.lock().unwrap().iter().copied().find(|e| e.day == day && e.name == name)
            }
        }

        fn main() {
            let tracing_enabled = std::env::var("RUST_TRACE").is_ok();
            if tracing_enabled {
                tracing_subscriber::fmt()
                    .pretty()
                    .without_time()
                    .with_max_level(tracing::Level::DEBUG)
                    .init();
                tracing::info!("Tracing enabled");
            } else {
                env_logger::init();
            }

            let day: &str = #day_str;

            use clap::{Parser, Subcommand, Args};

            #[derive(Parser)]
            #[command(name = env!("CARGO_PKG_NAME"))]
            struct Cli { #[command(subcommand)] command: Commands }

            #[derive(Subcommand)]
            enum Commands {
                List,
                Render(RenderArgs),
                Run(RunArgs),
                Bench(BenchArgs),
            }

            #[derive(Args)]
            struct RenderArgs {
                /// Run all registered render solutions for the day
                #[arg(long)]
                all: bool,
                /// Name of the render solution to run (if not using --all)
                name: Option<String>,
                /// Input path (use '-' for stdin)
                input: Option<String>,
            }

            #[derive(Args)]
            struct RunArgs {
                /// Run all registered solutions for the day
                #[arg(long)]
                all: bool,
                /// Name of the solution to run (if not using --all)
                name: Option<String>,
                /// Input path (use '-' for stdin)
                input: Option<String>,
            }

            #[derive(Args)]
            struct BenchArgs {
                /// Run all registered solutions for the day
                #[arg(long)]
                all: bool,
                /// Name of the solution to bench (if not using --all)
                name: Option<String>,
                /// Input path (use '-' for stdin)
                input: Option<String>,
                /// Number of warmup runs (default: 3)
                #[arg(long, default_value_t = 3)]
                warmup: usize,
                /// Number of benchmark iterations (default: 100)
                #[arg(long, default_value_t = 100)]
                iters: usize,
            }

            let cli = Cli::parse();

            let read_input = |input_path: String| -> String {
                if input_path == "-" { use std::io::Read; let mut s = String::new(); std::io::stdin().read_to_string(&mut s).expect("failed to read stdin"); s } else { std::fs::read_to_string(&input_path).unwrap_or_else(|e| panic!("failed to read {}: {}", input_path, e)) }
            };

            let benchmark = |name: &str, func: fn(&str) -> String, input: &str, warmup: usize, iters: usize| {
                // Warmup
                for _ in 0..warmup { let _ = func(input); }

                // Benchmark
                let mut times = Vec::with_capacity(iters);
                for _ in 0..iters {
                    let start = std::time::Instant::now();
                    let _ = func(input);
                    times.push(start.elapsed());
                }

                times.sort();
                let min = times[0];
                let max = times[iters - 1];
                let median = times[iters / 2];

                // Compute average and standard deviation (in nanoseconds)
                let sum_ns: u128 = times.iter().map(|d| d.as_nanos()).sum();
                let avg_ns = sum_ns as f64 / (iters as f64);
                let avg = std::time::Duration::from_nanos(avg_ns as u64);

                let var_ns = times
                    .iter()
                    .map(|d| {
                        let x = d.as_nanos() as f64;
                        let diff = x - avg_ns;
                        diff * diff
                    })
                    .sum::<f64>()
                    / (iters as f64);
                let stddev_ns = var_ns.sqrt();
                let stddev = std::time::Duration::from_nanos(stddev_ns as u64);

                println!("{name}: {avg:?} ± {stddev:?} [min: {min:?}, max: {max:?}, median: {median:?}]");
            };

            match cli.command {
                Commands::List => {
                    let entries = crate::__aoc::entries_for_day(day);
                    let render_entries = crate::__aoc::render_entries_for_day(day);
                    if entries.is_empty() && render_entries.is_empty() {
                        println!("No solutions registered for {}", day);
                    } else {
                        if !entries.is_empty() {
                            println!("Solutions:");
                            for e in entries { println!("  {}", e.name); }
                        }
                        if !render_entries.is_empty() {
                            println!("\nRender:");
                            for e in render_entries { println!("  {}", e.name); }
                        }
                    }
                }
                Commands::Render(args) => {
                    if args.all {
                        let input_path = match args.input {
                            Some(ip) => ip,
                            None => match args.name {
                                Some(pos) => pos,
                                None => {
                                    eprintln!("Missing input path for --all. Provide an input path (use '-' for stdin) or --input <FILE>");
                                    std::process::exit(2);
                                }
                            },
                        };
                        let input = read_input(input_path);
                        let entries = crate::__aoc::render_entries_for_day(day);
                        if entries.is_empty() { eprintln!("No render solutions registered for {}", day); std::process::exit(3); }
                        for e in entries { (e.func)(&input); }
                    } else {
                        let name = match args.name {
                            Some(n) => n,
                            None => { eprintln!("Missing solution name. Try 'list' to see registered names."); std::process::exit(2); }
                        };
                        let input_path = match args.input {
                            Some(i) => i,
                            None => { eprintln!("Missing input path. Provide an input path (use '-' for stdin) or --input <FILE>"); std::process::exit(2); }
                        };
                        let input = read_input(input_path);
                        match crate::__aoc::get_render(day, &name) { Some(entry) => { (entry.func)(&input); } None => { eprintln!("No such render solution: {}. Try 'list'.", name); std::process::exit(3); } }
                    }
                }
                Commands::Run(args) => {
                    if args.all {
                        // If --all is provided, require an input path. For backward compatibility we
                        // accept that callers may have supplied the input as the positional `name`.
                        let input_path = match args.input {
                            Some(ip) => ip,
                            None => match args.name {
                                Some(pos) => pos,
                                None => {
                                    eprintln!("Missing input path for --all. Provide an input path (use '-' for stdin) or --input <FILE>");
                                    std::process::exit(2);
                                }
                            },
                        };
                        let input = read_input(input_path);
                        let entries = crate::__aoc::entries_for_day(day);
                        if entries.is_empty() { eprintln!("No solutions registered for {}", day); std::process::exit(3); }
                        for e in entries { let out = (e.func)(&input); println!("{}: {}", e.name, out); }
                    } else {
                        let name = match args.name {
                            Some(n) => n,
                            None => { eprintln!("Missing solution name. Try 'list' to see registered names."); std::process::exit(2); }
                        };
                        let input_path = match args.input {
                            Some(i) => i,
                            None => { eprintln!("Missing input path. Provide an input path (use '-' for stdin) or --input <FILE>"); std::process::exit(2); }
                        };
                        let input = read_input(input_path);
                        match crate::__aoc::get(day, &name) { Some(entry) => { let out = (entry.func)(&input); println!("{}", out); } None => { eprintln!("No such solution: {}. Try 'list'.", name); std::process::exit(3); } }
                    }
                }
                Commands::Bench(args) => {
                    // Validate iteration count
                    if args.iters == 0 { eprintln!("--iters must be >= 1"); std::process::exit(2); }

                    if args.all {
                        // If --all is used, require an input path (positional or via --input)
                        let input_path = match args.input {
                            Some(ip) => ip,
                            None => match args.name {
                                Some(pos) => pos,
                                None => { eprintln!("Missing input path for --all. Provide an input path (use '-' for stdin) or --input <FILE>"); std::process::exit(2); }
                            },
                        };
                        let input = read_input(input_path);
                        let entries = crate::__aoc::entries_for_day(day);
                        if entries.is_empty() { eprintln!("No solutions registered for {}", day); std::process::exit(3); }
                        for e in entries { benchmark(e.name, e.func, &input, args.warmup, args.iters); }
                    } else {
                        let name = match args.name {
                            Some(n) => n,
                            None => { eprintln!("Missing solution name. Try 'list' to see registered names."); std::process::exit(2); }
                        };
                        let input_path = match args.input {
                            Some(i) => i,
                            None => { eprintln!("Missing input path. Provide an input path (use '-' for stdin) or --input <FILE>"); std::process::exit(2); }
                        };
                        let input = read_input(input_path);
                        match crate::__aoc::get(day, &name) { Some(entry) => { benchmark(entry.name, entry.func, &input, args.warmup, args.iters); } None => { eprintln!("No such solution: {}. Try 'list'.", name); std::process::exit(3); } }
                    }
                }
            }
        }
    };
    TokenStream::from(expanded)
}
```

Yeah. It's a lot. 

## Tests

And finally, our test macro!

I thought about using my [testit](https://blog.jverkamp.com/2024/08/19/testit-integration-testing-for-my-rust-solvers/) framework, but figured I might as well build it in.

The idea is that you specify the day, an input file, and then you can map as many sets of input functions to expected output as you want. Heck, you could even have multiple input files for smaller test cases if you wanted!

```rust
aoc::test!(file = "input/2025/day1.txt", [part1] => "1055", [part2, part2_inline] => "6386");
```

Or:

```rust
aoc::test!(text = "\
L68
L30
R48
L5
R60
L55
L1
L99
R14
L82", [part1] => "3", [part2, part2_inline] => "6");
```

That's pretty fun. 

```rust
pub fn test_impl(input: TokenStream) -> TokenStream {
    // Custom parser for new test macro syntax
    struct TestCase {
        solutions: Vec<Expr>,
        expected: LitStr,
    }

    enum InputSpec {
        File(LitStr),
        Text(LitStr),
    }

    struct TestInput {
        input_spec: InputSpec,
        cases: Vec<TestCase>,
    }

    impl Parse for TestInput {
        fn parse(input: ParseStream) -> syn::Result<Self> {
            // Accept either `file = "path"` or `text = "..."` here, or the legacy bare string literal (file path).
            let input_spec = if input.peek(syn::Ident) {
                let ident: syn::Ident = input.parse()?;
                input.parse::<syn::Token![=]>()?;
                let val: LitStr = input.parse()?;
                match ident.to_string().as_str() {
                    "file" => InputSpec::File(val),
                    "text" => InputSpec::Text(val),
                    other => {
                        return Err(syn::Error::new_spanned(
                            ident,
                            format!("expected `file` or `text`, got `{}`", other),
                        ));
                    }
                }
            } else {
                // Legacy form: just a string literal which is treated as a file path
                let val: LitStr = input.parse()?;
                InputSpec::File(val)
            };

            let mut cases = Vec::new();

            while !input.is_empty() {
                input.parse::<syn::Token![,]>()?;

                // Parse [solution1, solution2, ...]
                let content;
                syn::bracketed!(content in input);
                let solutions: Vec<Expr> = content
                    .parse_terminated(Expr::parse, syn::Token![,])?
                    .into_iter()
                    .collect();

                input.parse::<syn::Token![=>]>()?;
                let expected: LitStr = input.parse()?;

                cases.push(TestCase {
                    solutions,
                    expected,
                });
            }

            Ok(TestInput { input_spec, cases })
        }
    }

    let test_input = parse_macro_input!(input as TestInput);
    let input_spec = test_input.input_spec;

    // Build a unique source tag based on input type and content/path to avoid name collisions.
    fn short_hash(s: &str) -> String {
        use std::hash::{Hash, Hasher};
        let mut h = std::collections::hash_map::DefaultHasher::new();
        s.hash(&mut h);
        let v = h.finish();
        format!("{:x}", v)[..8].to_string()
    }
    let source_tag_str = match &input_spec {
        InputSpec::File(p) => {
            let path = p.value();
            let hash = short_hash(&path);
            // Take last component for readability
            let last = path.rsplit('/').next().unwrap_or(&path);
            let sanitized: String = last
                .chars()
                .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })
                .collect();
            format!("file_{}_{}", sanitized, hash)
        }
        InputSpec::Text(t) => {
            let text = t.value();
            let hash = short_hash(&text);
            format!("text_{}", hash)
        }
    };

    // Precompute the input binding tokens (same for all cases in this macro invocation)
    let input_binding = match &input_spec {
        InputSpec::File(p) => {
            let p_lit = p.clone();
            quote! { let input = std::fs::read_to_string(#p_lit).unwrap_or_else(|e| panic!("failed to read {}: {}", #p_lit, e)); }
        }
        InputSpec::Text(t) => {
            let t_lit = t.clone();
            quote! { let input = #t_lit.to_string(); }
        }
    };

    // Generate test functions; include case and solution indices for full uniqueness.
    let test_functions: Vec<_> = test_input
        .cases
        .iter()
        .flat_map(|test_case| {
            let expected = test_case.expected.value();
            let source_tag_str = source_tag_str.clone();
            let input_binding_outer = input_binding.clone();

            test_case
                .solutions
                .iter()
                .map(move |solution_expr| {
                    let name_str = crate::expr_to_string(solution_expr);
                    let test_name = quote::format_ident!("test_{}_{}", source_tag_str, name_str);
                    let name_lit = name_str.clone();
                    let expected_lit = expected.clone();
                    let input_binding_clone = input_binding_outer.clone();

                    quote! {
                        #[test]
                        fn #test_name() {
                            #input_binding_clone
                            let entry = crate::__aoc::get(crate::__aoc::DAY, #name_lit)
                                .unwrap_or_else(|| panic!("solution {} not found", #name_lit));
                            let result = (entry.func)(&input);
                            assert_eq!(result, #expected_lit, "test failed for {}", #name_lit);
                        }
                    }
                })
                .collect::<Vec<_>>()
        })
        .collect();

    let expanded = quote! {
        #(#test_functions)*
    };

    TokenStream::from(expanded)
}
```

Originally, I didn't support both files and text, but in a lot of Advent of Code problems, you are given a small test case which it's useful to solve first. I did have to add the hashes though, since otherwise we'll generate the same name twice. Now you have:

```bash
running 6 tests
test test_day1_text_f9cee729_part1 ... ok
test test_day1_text_f9cee729_part2_inline ... ok
test test_day1_text_f9cee729_part2 ... ok
test test_day1_file_day1_txt_71e8dd21_part1 ... ok
test test_day1_file_day1_txt_71e8dd21_part2_inline ... ok
test test_day1_file_day1_txt_71e8dd21_part2 ... ok
```

Which is pretty nice, IMO. 

On to [[AoC 2025 Day 1: Turn Turn Turninator|day 1]]()!