categories:
- Programming/By Language/Racket
- Programming/By Language/Scheme
- Programming/By Topic/Games
- Programming/By Topic/Graphics
- Programming/By Topic/Mathematics
- Programming/By Topic/Noise
- Programming/Libraries
comments: true
date: 2013-04-11 14:00:28
layout: post
title: Perlin and simplex noise in Racket
---
Many games need noise. No, not @wikipedia["that noise"]{Noise}--@wikipedia["this noise"]{Perlin noise}. Or better yet, @wikipedia["this noise"]{Simplex noise}. More seriously, noise in this context refers to psuedo-randomly generated images that can be used for natural looking terrain generation@footnote{Among many, many other uses}. Something like this:

@embed{simplex-colored-256x256-16x.png}

<!--more-->

So how do we generate such images? Essentially, you want to write a function that takes coordinates (in 1-, 2-, 3- or even more dimensional space) and returns a single value. Calling the function multiple times for the same coordinate will always return the same value, thus the psudeo-random nature of the algorithm. This also allows for things like persistent level generation using only a seed, such as <a title="Minecraft Wiki: Seed (level generation)" href="http://www.minecraftwiki.net/wiki/World_Generation_Seeds">world generation</a> in <a title="Minecraft" href="https://minecraft.net/">Minecraft</a>.

One simple idea might be to use a simple seeded random number generator. For example, we could do something like the following:

@codeblock["scheme"]|{
(define (seeded x [y 0] [z 0])
  (random-seed (+ x y z))
  (- (* 2.0 (random)) 1.0))
}|

And we can test it like so:

@codeblock["scheme"]|{
> (for/list ([i (in-range 5)])
    (for/list ([j (in-range 5)])
      (round-to (seeded i j) 2)))
'((0.71 0.01 0.3 0.89 0.79)
  (0.01 0.3 0.89 0.79 -0.22)
  (0.3 0.89 0.79 -0.22 -0.92)
  (0.89 0.79 -0.22 -0.92 0.83)
  (0.79 -0.22 -0.92 0.83 0.64))
}|

So long as they haven't changed the PRNG backing Racket, you should be able to type in that code and get exactly the same values. Every time you run the function, you'll get the same values. We could even turn it into a pretty picture:

@codeblock["scheme"]|{
(build-image
 256 256
 (lambda (x y)
   (define g (clamp -1.0 1.0 (seeded x y)))
   (float-color g g g)))
}|

`build-image` is from the Racket package @racket-doc{picturing-programs}. `clamp` and `float-color` are defined in <a title="noisy-image-test.rkt" href="https://github.com/jpverkamp/noise/blob/master/noisy-image-test.rkt">noisy-image-test.rkt</a> which you can see on GitHub (and I'll talk more about them later).

In any case, using the above code you'll get something (exactly) like this:

@embed{seeded-plus.png}

Not exactly what we were hoping for. What's going on here is that because we used `(+ x y z)` as our seed, the function will return the same value for the points (0 1) and (1 0). Not exactly something that we want. But luckily, there are all sorts of more interesting functions that we could use to generate the random seed. For example, we could multiple the numbers together.

@embed{seeded-mul-0.png}

Well, no. Actually we can't. It turns out that if we multiple the number but are only generating the x and y, then we're always multiplying by 0. We can fix this pretty easily by changing the line in the `build-image` call from `(seeded x y)` to `(seeded x y 1)`. This gives us a much more reasonable result:

@embed{seeded-mul.png}

There are also some options that you can use that will give you some really interesting results. For example, if you use `bitwise-xor` instead of `+` or `*`, you'll get this:

@embed{seeded-xor.png}

It's not particularly useful for what we're looking for at the moment, but it's still really cool.

One problem that all of these images have that we want to try and solve is that none of them are particularly 'smooth'. Neighboring values have essentially no relation to each other, so if we tried to use them directly to generate something like terrain, it's going to look obviously artificial. So what we really want is not only a consistent pseudo-random function, but also one that is smooth.

There are a number of ways that we could go about this, but to make a long story shorter@footnote{Too late...} two of the most commonly used algorithms are called @wikipedia{Perlin noise} and @wikipedia{simplex noise}. Both algorithms were originally implemented by @wikipedia{Ken Perlin}, Perlin noise in the 1980s@footnote{He actually won a @wikipedia{Academy Award for Technical Achievement} for it in 1997. I didn't even know that was a thing...} and simplex noise in 2001.

Browsing around the Internet, I found a relatively clean and well commented version for both of them in <a title="PDF describing Perlin and simplex noise" href="http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">this PDF</a>. The original code was written in C, but it was surprisingly straightforward to convert it to Racket. It's certainly not the fastest code (I haven't really gone that far into optimizing Racket code. If anyone has any advice for as such, I'd love to hear it!), but it does exactly what it's designed to do. Here is the code on GitHub: <a title="noise source on GitHub" href="https://github.com/jpverkamp/noise/blob/master/noise.rkt">noise.rkt</a>.

Really, there are two functions of interest:

@codeblock["scheme"]|{
; Generate 1D/2D/3D Perlin noise
; Always uses a 3D generator in the background
(perlin x [y 0.0] [z 0.0])

; Generate 1D/2D/3D simplex noise
; Always uses a 3D generator in the background
(simplex x [y 0.0] [z 0.0])
}|

In each case, you can specify one to three dimensions. For example, these are all valid calls:

@codeblock["scheme"]|{
> (for/list ([i 10]) (round-to (perlin (/ i 10)) 2))
'(0.0 0.11 0.23 0.37 0.46 0.5 0.46 0.37 0.23 0.11)

> (for/list ([i 10]) 
    (for/list ([j 10])
      (round-to (simplex (/ i 10) (/ j 10)) 2)))
'((0.0 0.44 0.68 0.63 0.32 -0.01 -0.1 0.08 0.39 0.67)
  (0.44 0.81 0.94 0.78 0.43 0.12 0.05 0.22 0.46 0.63)
  (0.69 0.94 0.95 0.72 0.38 0.12 0.06 0.16 0.3 0.41)
  (0.67 0.79 0.73 0.51 0.24 0.03 -0.05 -0.05 0.02 0.1)
  (0.5 0.5 0.4 0.25 0.11 -0.02 -0.15 -0.23 -0.23 -0.15)
  (0.31 0.24 0.16 0.12 0.08 0.0 -0.15 -0.29 -0.33 -0.27)
  (0.14 0.09 0.07 0.11 0.15 0.1 -0.04 -0.2 -0.29 -0.27)
  (-0.08 -0.05 0.01 0.12 0.22 0.23 0.13 -0.03 -0.16 -0.24)
  (-0.39 -0.26 -0.11 0.07 0.23 0.3 0.26 0.13 -0.07 -0.28)
  (-0.67 -0.45 -0.22 -0.01 0.16 0.26 0.27 0.15 -0.09 -0.39))

> (perlin 3.14 1.59 2.65)
-0.3772216257243449
}|

Both of the functions will scale roughly in the range [-1.0, 1.0] as in the original implementation. If you look closely and sort of squint, these functions have something that the original functions didn't have: they're smooth. Values generated on coordinates near to each other are similar. It will be much easier if we happened to have functions that could visualize these. @racket-doc{picturing-programs} to the rescue!

Using essentially the same code as before, we now have everything we need to generate these images. As I said, there are two helper functions that I needed to write. `clamp` will take a number in the range [-1.0, 1.0] (or any range really) and scale it to [0.0, 1.0]. `float-color` takes @wikipedia{RGB}values in the range [0.0, 1.0] and scales them to bytes in the range [0, 255] so we can make a color. You can see the code for both of those <a title="noisy-image-test.rkt" href="https://github.com/jpverkamp/noise/blob/master/noisy-image-test.rkt">on GitHub</a>--they should be pretty straight forward.

With that, here's a function that can generate any sized image (with a scaling factor) from Perlin noise:

@codeblock["scheme"]|{
; Build an image using perlin noise
(define (build-perlin-image w h #:scale [scale 1.0])
  (build-image 
   w h
   (lambda (x y)
     (define g (clamp -1.0 1.0 (perlin (* scale (/ x w))
                                       (* scale (/ y h)))))
     (float-color g g g))))
}|

Here are a bunch of images I've generated using the Perlin/simplex image functions:

<table class="table table-striped">
<tr><td></td><td>1x</td><td>4x</td></tr>

<tr><td>perlin</td>
<td>@embed{perlin-256x256.png}</td>

<td>@embed{perlin-256x256-4x.png}</td>
</tr>

<tr><td>simplex</td>
<td>@embed{simplex-256x256.png}</td>

<td>@embed{simplex-256x256-4x.png}</td>

<tr><td>colored simplex</td>
<td>@embed{simplex-colored-256x256.png}</td>

<td>@embed{simplex-colored-256x256-4x.png}</td>
</td></tr></table>

From left to right, top to bottom, we have Perlin noise, simplex noise, and colored simplex noise, each with a scaling factor of 1x then 4x. The colored simplex noise generator actually makes use of the z-coordinate, setting it to -1 for the red channel, 0 for the green channel, and 1 for the blue channel@footnote{Yay @wikipedia["magic numbers"]{Magic number (programming)}!}. You can see any of the functions <a title="noisy-image-test.rkt" href="https://github.com/jpverkamp/noise/blob/master/noisy-image-test.rkt">on GitHub</a>, they're all pretty much the same as the one showed before.

And that's basically it. There are all sorts of ways that you can make use of noise. Theoretically, I'll have an example of using it to generate an infinite scrolling dungeon in a few minutes in my ongoing Racket roguelike tutorial series.

Finally, just out of curiosity, I timed the generation of each of those images above (and a few more) and included it in the table below. It takes almost two seconds even for the simplest 256x256 images, which certainly isn't optimal (at that size the code should be able to run in essentially real time). Like I said, if anyone with more experience optimizing Racket code wants to take a crack at it, go for it. I'd love to see it.
<table class="table table-striped">
<thead>
<tr>
<td></td>
<td colspan="3">256x256</td>
<td colspan="2">512x512</td>
</tr>
<tr>
<td></td>
<td>1x</td>
<td>4x</td>
<td>16x</td>
<td>4x</td>
<td>slowdown</td>
</tr>
</thead>
<tbody>
<tr>
<td>perlin</td>
<td>1716</td>
<td>2995</td>
<td>2715</td>
<td>12433</td>
<td>4.15</td>
</tr>
<tr>
<td>simplex</td>
<td>1436</td>
<td>1529</td>
<td>1560</td>
<td>7504</td>
<td>4.91</td>
</tr>
<tr>
<td>colored</td>
<td>3697</td>
<td>4103</td>
<td>3978</td>
<td>17145</td>
<td>4.18</td>
</tr>
</tbody>
</table>

If you'd like to check out the entire project, you can do so here:
<a href="https://github.com/jpverkamp/noise" title="noise on GitHub">noise</a>

If you have any comments about either coding style or optimizations, I'd love to hear them. It's certainly not pure functional code but rather a more or less direct translation of the original Java (I did clean up a few things).